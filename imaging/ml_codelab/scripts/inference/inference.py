# Copyright 2018 Google LLC. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""Inference via AutoML or Cloud ML engine.

The inference module allows medical imaging ML models to be more easily
integrated into clinical workflows. PACS systems (and other imaging archives)
can push DICOM instances into Cloud Healthcare DICOM stores, allowing ML models
to be triggered for inference. This inference results can then be stored as
DICOM structured reports in the Cloud Healthcare API, which can be retrieved by
the customer. This script does the following actions:

1) Listens to new DICOM to be inserted into a DICOM Store via Cloud Pubsub.

   When new DICOM instances are stored in Cloud Healthcare API, a Cloud Pubsub
   message is generated for the new instance. This module will listen to all
   incoming messages for the Cloud Pubsub subscription specified in
   --subscription_path.

2) Retrieves the instance from Cloud Healthcare API.

   The DICOMWeb WADO-RS request will be invoked to retrieve the DICOM instance.
   Since the model is trained on JPEG images, this script will retrieve the
   instance in that format. It will utilize the Cloud Healthcare API's ability
   to transcode instances in comsumer format (e.g. JPEG).

3) Invokes Cloud Machine Learning Engine for Inference.

   The image in JPEG format will be sent to the pre-trained model (specified
   by --model_path) served by Cloud ML Engine. Cloud ML Engine will return both
   the predicted class and the score for the image.

4) Store the inference results in Cloud Healthcare API.

   This step is optional and is only enabled by setting the
   --dicom_store_path flag.

   The inference results can be stored as a DICOM structured report. This is
   a format that can store free text format (amongst other things). In this
   case, the script is going to store the predicted class and score from step
   (3). This DICOM strucuted report will be stored back to the Cloud Healthcare
   API in the given DICOM store (--dicom_store_path). This instance
   can be then be retrieved by the client.
"""

from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import abc
import argparse
import base64
from email import encoders
from email.mime import application
from email.mime import multipart
import json
import logging
import email.generator
import os
import re
import sys
import traceback
import uuid

import attr
import googleapiclient.discovery
import httplib2
from oauth2client.client import GoogleCredentials
from requests_toolbelt.multipart import decoder
import tags

from google.api_core.exceptions import InvalidArgument
from google.api_core.exceptions import PermissionDenied
from google.cloud import automl_v1beta1
from google.cloud import pubsub_v1
# Output this module's logs (INFO and above) to stdout.
_logger = logging.getLogger(__name__)
_logger.addHandler(logging.StreamHandler(sys.stdout))
_logger.setLevel(logging.INFO)

FLAGS = None

# Prefix for Cloud Healthcare API.
_HEALTHCARE_API_URL_PREFIX = 'https://healthcare.googleapis.com/v1beta1'

# Credentails used to access Cloud Healthcare API.
_CREDENTIALS = GoogleCredentials.get_application_default().create_scoped(
    ['https://www.googleapis.com/auth/cloud-platform'])

# SOP Class UID for Basic Text Structured Reports.
_BASIC_TEXT_SR_CUID = '1.2.840.10008.5.1.4.1.1.88.11'

# DICOM Tags.
_SOP_INSTANCE_UID_TAG = '00080018'
_SOP_CLASS_UID_TAG = '00080016'

_VALUE_TYPE = 'Value'

# Number of times to retry failing CMLE predictions.
_NUM_RETRIES_CMLE = 5

# Prefix of the UIDs generated by the module.
_UUID_INFERENCE_PREFIX = '2.25'

# Accepted character set.
_CHARACTER_SET = 'ISO_IR 192'

# Little Endian Transfer Syntax.
_IMPLICIT_VR_LITTLE_ENDIAN = '1.2.840.10008.1.2'


def _WadoRs(instance_path):
  # type: str -> str
  """Receives instance in JPEG format using WADO-RS protocol.

  WADO-RS is one of the standard protocols specified by DICOMWeb protocol. It
  allows clients to retrieve instances in various formats. In this case we will
  retrieve the instance in JPEG format, from the Cloud Healthcare API specified
  by _HEALTHCARE_API_URL_PREFIX.

  Args:
    instance_path: Path of DICOM instance. This is found in the contents of the
      Pubsub message. This should be formatted as follows:
        projects/{PROJECT_ID}/locations/{LOCATION_ID}/datasets/{DATASET_ID}/
        dicomStores/{DICOM_STORE_ID}/dicomWeb/studies/{STUDY_UID}/series/
        {SERIES_UID}/instances/{INSTANCE_UID}

  Returns:
    content: The bytes for the JPEG image.

  Raises:
    RuntimeError: If failed to retrieve or process instance.
  """
  wado_url = os.path.join(_HEALTHCARE_API_URL_PREFIX, instance_path)
  http = httplib2.Http()
  http = _CREDENTIALS.authorize(http)

  # Headers for receiving DICOM in JPEG Baseline format.
  headers = {
      'Accept': 'multipart/related; type="image/jpeg"; '
                'transfer-syntax=1.2.840.10008.1.2.4.50'
  }
  resp, content = http.request(wado_url, 'GET', headers=headers)
  if resp.status != 200:
    raise RuntimeError(
        'Failed to retrieve DICOM instance: (%s, %s)' % (resp, content))

  multipart_data = decoder.MultipartDecoder(content, resp['content-type'])
  if len(multipart_data.parts) != 1:
    raise RuntimeError('Invalid number of WADO-RS response parts (need 1): %s' %
                       (str(len(multipart_data.parts))))
  return multipart_data.parts[0].content


def _StowRs(study_path, jsonstr):
  # type: (str, str) -> None
  """Stores instance in Cloud Healthcare API using STOW-RS protocol.

  STOW-RS is one of the standard protocols specified by DICOMWeb protocol. It
  allows clients to store DICOM instances. In this case we will
  store the instance in in the Cloud Healthcare API specified by
  _HEALTHCARE_API_URL_PREFIX.

  Args:
    study_path: Path of DICOM study. This should be formatted as follows:
      projects/{PROJECT_ID}/locations/{LOCATION_ID}/datasets/{DATASET_ID}/
      dicomStores/{DICOM_STORE_ID}/dicomWeb/studies
    jsonstr: JSON represenation of DICOM instance(s) to store.

  Raises:
    RuntimeError: If failed to store instance.
  """
  stow_url = os.path.join(_HEALTHCARE_API_URL_PREFIX, study_path)
  http = httplib2.Http()
  http = _CREDENTIALS.authorize(http)
  application_type = 'dicom+json'

  root = multipart.MIMEMultipart(
      subtype='related', boundary=email.generator._make_boundary())
  # root should not write out its own headers
  setattr(root, '_write_headers', lambda self: None)
  part = application.MIMEApplication(
      jsonstr, application_type, _encoder=encoders.encode_noop)
  root.attach(part)

  boundary = root.get_boundary()
  content_type = ('multipart/related; type="application/%s"; boundary="%s"') % (
      application_type, boundary)
  headers = {'content-type': content_type}

  resp, content = http.request(
      stow_url, method='POST', body=root.as_string(), headers=headers)
  if resp.status != 200:
    raise RuntimeError(
        'Failed to store DICOM instance in Healthcare API: (%s, %s)' %
        (resp.status, content))


def _QidoRs(qido_url):
  # type: str -> List
  """Performs the request, and returns the parsed JSON response.

  QIDO-RS is one of the standard protocols specified by DICOMWeb protocol. It
  allows clients to query metadata for DICOM instances. In this case we will
  store the instance in in the Cloud Healthcare API specified by
  _HEALTHCARE_API_URL_PREFIX.

  Args:
    qido_url: URL for the QIDO request.

  Returns:
    The parsed JSON response content.

  Raises:
    RuntimeError: if the response status was not 200.
  """
  http = httplib2.Http()
  http = _CREDENTIALS.authorize(http)
  resp, content = http.request(qido_url, 'GET')
  if resp.status != 200:
    raise RuntimeError(
        'QidoRs error. Response Status: %d,\nURL: %s,\nContent: %s.' %
        (resp.status, qido_url, content))
  return json.loads(content)


class Predictor(object):
  """Abstract base class for ML Predictor."""
  __metaclass__ = abc.ABCMeta

  @abc.abstractmethod
  def Predict(self, image_jpeg_bytes):
    # type: str -> (str, str)
    """Runs inference and returns predicted class and score."""
    raise NotImplementedError


class CMLEPredictor(Predictor):
  """Handler for CMLE predictor.

  Attributes:
    model_path: Path to model.
  """

  def __init__(self, model_path):
    self._model_path = model_path

  def Predict(self, image_jpeg_bytes):
    # type: str -> (str, str)
    """Runs inference on image using Cloud ML Engine.

    This will invoke the model with the given image and will return the
    predicted class and score.

    Args:
      image_jpeg_bytes: Bytes of JPEG image.

    Returns:
      (class, score) tuple.

      class is the predicted class.
      score is the predicted score.

    Raises:
      RuntimeError: if failed to get inference results.
    """

    # CMLE requires images to be encoded in this format:
    # https://cloud.google.com/ml-engine/docs/v1/predict-request
    input_data = {
        'instances': [{
            'inputs': {
                'b64': base64.b64encode(image_jpeg_bytes).decode()
            }
        }]
    }
    # Disable cache discovery due to following issue:
    # https://github.com/google/google-api-python-client/issues/299
    service = googleapiclient.discovery.build('ml', 'v1', cache_discovery=False)
    response = service.projects().predict(
        name=self._model_path,
        body=input_data).execute(num_retries=_NUM_RETRIES_CMLE)

    # Propagate the error.
    if 'error' in response:
      raise RuntimeError(response['error'])

    # Return the predictions.
    prediction = response['predictions'][0]
    return prediction['classes'], prediction['scores']


class AutoMLPredictor(Predictor):
  """Handler for AutoML Vision predictor.

  Attributes:
    model_path: Path to model.
  """

  def __init__(self, model_path):
    self._model_path = model_path

  def Predict(self, image_jpeg_bytes):
    # type: str -> (str, str)
    """Runs inference on image using AutoML.

    This will invoke the model with the given image and will return the
    predicted class and score.

    Args:
      image_jpeg_bytes: Bytes of JPEG image.

    Returns:
      (class, score) tuple.

      class is the predicted class.
      score is the predicted score.

    Raises:
      RuntimeError: if failed to get valid inference results.
    """
    payload = {'image': {'image_bytes': image_jpeg_bytes}}
    params = {}
    prediction_client = automl_v1beta1.PredictionServiceClient()
    response = prediction_client.predict(self._model_path, payload, params)
    if len(response.payload) != 1:
      raise RuntimeError('AutoML response payload size should be of size 1')
    result = response.payload[0]
    return result.display_name, result.classification.score


def _InsertJSONTag(dataset, tag, value):
  # type: (Dict, tags.DicomTag, Any) -> None
  """Inserts a Dicom Tag into passed Dict.

  Args:
    dataset: Dict where the tag will be inserted.
    tag: A DICOM tag.
    value: Any type that will be inserted into dict as the value for the tag.
  """
  dataset[tag.number] = {'vr': tag.vr, 'Value': [value]}
  return


def _BuildJSONSR(text, series_uid, instance_uid, study_json):
  # type: (str, str, str, Dict) -> str
  """Builds and returns a Basic Text DICOM JSON Structured Report instance.

  Args:
    text: Text string to use for the Basic Text DICOM SR.
    series_uid: UID of the series to use for the SR.
    instance_uid: UID of the SR instance.
    study_json: Dict of study level information to populate the SR.

  Returns:
    Encoded JSON form of the DICOM instance.
  """

  # Dicom StowJsonRs expects a list with DICOM JSON as elements.
  # Add study level tags to the SR.
  dataset = study_json
  _InsertJSONTag(dataset, tags.SOP_CLASS_UID, _BASIC_TEXT_SR_CUID)
  _InsertJSONTag(dataset, tags.SERIES_INSTANCE_UID, series_uid)
  _InsertJSONTag(dataset, tags.SOP_INSTANCE_UID, instance_uid)
  _InsertJSONTag(dataset, tags.SPECIFIC_CHARACTER_SET, _CHARACTER_SET)

  content_dataset = {}
  _InsertJSONTag(content_dataset, tags.RELATIONSHIP_TYPE, 'CONTAINS')
  _InsertJSONTag(content_dataset, tags.VALUE_TYPE, 'TEXT')
  _InsertJSONTag(content_dataset, tags.TEXT_VALUE, text)
  _InsertJSONTag(dataset, tags.CONTENT_SEQUENCE, content_dataset)

  _InsertJSONTag(dataset, tags.TRANSFER_SYNTAX_UID, _IMPLICIT_VR_LITTLE_ENDIAN)
  _InsertJSONTag(dataset, tags.MEDIA_STORAGE_SOP_CLASS_UID, _BASIC_TEXT_SR_CUID)
  _InsertJSONTag(dataset, tags.MEDIA_STORAGE_SOP_INSTANCE_UID, instance_uid)

  jsonstr = json.dumps([dataset])
  return jsonstr


def _GenerateUID(prefix=_UUID_INFERENCE_PREFIX):
  # type: str -> str
  """Generates a random Instance UID in the correct format.

  Args:
    prefix: Text string that is the UUID prefix for the UUID.

  Returns:
    Unique UID with the provided prefix.
  """
  return prefix + '.' + str(uuid.uuid4().int)


@attr.s
class ParsedMessage(object):
  """ParsedMessage represents the parsed Pub/Sub message.

  Attributes:
    dicomweb_url: The dicom URL.
    study_uid: Study UID.
  """
  dicomweb_url = attr.ib()  # type: str
  study_uid = attr.ib()  # type: str


class PubsubMessageHandler(object):
  """Handler for incoming Pubsub messages.

  Attributes:
    publisher: PublisherClient used to publish pubsub messages.

  Args:
    predictor: Object used to get prediction results.
    dicom_store_path: DICOM store used to store inference results.
  """

  def __init__(self, predictor, dicom_store_path):
    self._predictor = predictor
    self._dicom_store_path = dicom_store_path
    self._success_count = 0
    self.publisher = pubsub_v1.PublisherClient()

  def _ParseMessage(self, message):
    # type: pubsub_v1.Message -> Optional[ParsedMessage]
    """Returns the parsed pubsub message and filters malformed/non-MG messages.

    Checks that the path is valid. Also filters out non-MG modality.

    Args:
      message: Pubsub message.

    Returns:
      ParsedMessage or None if the message is invalid.
    """
    image_instance_path = message.data.decode()
    regexp = (r'projects/([^/]+)/locations/([^/]+)/datasets/([^/]+)/dicomStores'
              '/([^/]+)/dicomWeb/studies/([^/]+)/series/([^/]+)/instances/'
              '([^/]+)/?$')
    match = re.match(regexp, image_instance_path)
    if (match is None) or (len(match.groups()) != 7):
      return None
    project_id = match.group(1)
    location_id = match.group(2)
    dataset_id = match.group(3)
    dicom_store_id = match.group(4)
    study_uid = match.group(5)
    series_uid = match.group(6)
    instance_uid = match.group(7)
    dicomweb_url = ('%s/projects/%s/locations/%s/datasets/%s/dicomStores/%s/'
                    'dicomWeb' % (_HEALTHCARE_API_URL_PREFIX, project_id,
                                  location_id, dataset_id, dicom_store_id))
    qido_url = ('%s/studies/%s/series/%s/instances?SOPInstanceUID=%s&'
                'includefield=%s' % (dicomweb_url, study_uid, series_uid,
                                     instance_uid, tags.MODALITY_TAG.number))
    parsed_content = _QidoRs(qido_url)[0]
    modality_dict = parsed_content.get(tags.MODALITY_TAG.number, {})
    if modality_dict.get(_VALUE_TYPE, [None])[0] != 'MG':
      return None
    return ParsedMessage(study_uid=study_uid, dicomweb_url=dicomweb_url)

  def _PublishInferenceResultsReady(self, image_instance_path):
    # type: str -> None
    """Publishes a results ready notification to the supplied Pubsub channel.

    If the Inference Module is supplied FLAGS.publisher_topic_path flag, it will
    attempt to publish any inference results to that channel.

    Args:
      image_instance_path: Path of DICOM study. This should be formatted as
        follows
        projects/{PROJECT_ID}/locations/{LOCATION_ID}/datasets/{DATASET_ID}/
        dicomStores/{DICOM_STORE_ID}/dicomWeb/studies/{STUDY_ID}/series/
        ${SERIES_ID}/instances/{INSTANCE_ID}
    """
    if FLAGS.publisher_topic_path is None:
      return

    try:
      self.publisher.publish(
          FLAGS.publisher_topic_path, data=image_instance_path)
      _logger.info('Published inference results ready message')
    except TypeError as e:
      _logger.error('Invalid type sent to publish channel: %s', e.message)

  def PubsubCallback(self, message):
    # type: pubsub_v1.Message -> None
    """Processes a Pubsub message.

    This function handles the processing of a single Pub/Sub message. It will
    ACK any message that leads to an exception.

    Args:
      message: pubsub_v1.Message being processed.
    """
    try:
      self._PubsubCallback(message)
    except Exception as e:  # pylint: disable=broad-except
      # This is pretty broad exception handling, real deployments should try
      # to have more robust error handing.
      _logger.error(e)
      traceback.print_exc()
      _logger.error('Unexpected exception...acking message')
      message.ack()

  def _PubsubCallback(self, message):
    # type: pubsub_v1.Message -> None
    """Processes a Pubsub message.

    This function will retrieve the instance (specified in Pubsub message) from
    the Cloud Healthcare API. Then it will invoke CMLE to get the prediction
    results. Finally (and optionally), it will store the inference results back
    to the Cloud Healthcare API as a DICOM Structured Report. The instance URL
    to the Structured Report containing the prediction is then published to a
    pub/sub.

    Args:
      message: Incoming pubsub message.
    """
    image_instance_path = message.data.decode()
    _logger.debug('Received instance in pubsub feed: %s', image_instance_path)
    parsed_message = self._ParseMessage(message)
    if not parsed_message:
      _logger.info('Ignoring new message: %s', image_instance_path)
      message.ack()
      return

    _logger.info('Processing instance: %s', image_instance_path)

    # Retrieve instance from DICOM API in JPEG format.
    image_jpeg_bytes = _WadoRs(image_instance_path)
    # Retrieve study level information
    qido_study_url = ('%s/studies?StudyInstanceUID=%s&includefield=all' %
                      (parsed_message.dicomweb_url, parsed_message.study_uid))
    study_json = _QidoRs(qido_study_url)[0]
    # Get the predicted score and class from the inference model in Cloud ML or
    # AutoML.
    try:
      predicted_class, predicted_score = self._predictor.Predict(
          image_jpeg_bytes)
    except PermissionDenied as e:
      _logger.error('Permission error running prediction service: %s',
                    e.message)
      message.nack()
      return
    except InvalidArgument as e:
      _logger.error('Invalid arguments when running prediction service: %s',
                    e.message)
      message.nack()
      return

    # Print the prediction.
    text = 'Base path: %s\nPredicted class: %s\nPredicted score: %s' % (
        image_instance_path, predicted_class, predicted_score)
    _logger.info(text)

    # If user requested destination DICOM store for inference, create a DICOM
    # structured report that stores the prediction.
    if self._dicom_store_path:
      # Generate series uid and instance uid for the structured report.
      sr_instance_uid = _GenerateUID()
      sr_series_uid = _GenerateUID()

      # Store the DICOM structured report in a different series using Healthcare
      # API.
      dicom_sr = _BuildJSONSR(text, sr_series_uid, sr_instance_uid, study_json)
      study_path = os.path.join(self._dicom_store_path, 'dicomWeb', 'studies')
      try:
        _StowRs(study_path, dicom_sr)
      except RuntimeError as e:
        _logger.error('Error storing DICOM in API: %s', e.message)
        message.nack()
        return

      # If user requested that new structured reports be published to a channel,
      # publish the instance path of the Structured Report
      structured_report_path = os.path.join(
          study_path, parsed_message.study_uid, 'series', sr_series_uid,
          'instances', sr_instance_uid)
      self._PublishInferenceResultsReady(structured_report_path)
      _logger.info('Published structured report with path: %s',
                   structured_report_path)
    # Ack the message (successful or invalid message).
    message.ack()
    self._success_count += 1

  def GetSuccessCount(self):
    # type: None -> int
    """Returns the number of Pubsub messages successfully processed."""
    return self._success_count


def main():
  if FLAGS.prediction_service == 'CMLE':
    predictor = CMLEPredictor(FLAGS.model_path)
  elif FLAGS.prediction_service == 'AutoML':
    predictor = AutoMLPredictor(FLAGS.model_path)
  else:
    raise ValueError('FLAGS.prediction_service must be CMLE or AutoML.')

  handler = PubsubMessageHandler(predictor, FLAGS.dicom_store_path)
  subscriber = pubsub_v1.SubscriberClient()
  future = subscriber.subscribe(FLAGS.subscription_path, handler.PubsubCallback)
  try:
    # If timeout is set, wait for FLAGS.pubsub_timeout seconds until messages
    # are processed on the pubsub channel.
    future.result(timeout=FLAGS.pubsub_timeout)
  except KeyboardInterrupt:
    # User exits the script early.
    future.cancel()
    _logger.info('Received keyboard interrupt, exiting...')
  except pubsub_v1.exceptions.TimeoutError:
    # No messages are processed in FLAGS.pubsub_timeout seconds.
    future.cancel()
    assert (handler.GetSuccessCount() >
            0), 'Timeout but no pubsub messages successfully processed'


if __name__ == '__main__':
  parser = argparse.ArgumentParser()
  parser.add_argument(
      '--subscription_path',
      type=str,
      required=True,
      help=
      'Pub/Sub Subscription ID associated with the topic for notifications of '
      'new DICOM instances. The Inference Module subscribes to notifications on'
      ' this channel and runs inference on new DICOM instances added to the '
      'store.')
  parser.add_argument(
      '--publisher_topic_path',
      type=str,
      required=False,
      help=
      'Pub/Sub topic id, which is used to indicate that inference results are '
      'ready. Each notification contains a path to the DICOM Structured Report '
      'containing predictions.')
  parser.add_argument(
      '--model_path',
      type=str,
      required=True,
      help='Path of Cloud ML Engine model used for inference.')
  parser.add_argument(
      '--dicom_store_path',
      type=str,
      default='',
      help=
      'DICOM store used to store inference results. If empty, this script will '
      'not attempt to store inference results back into Healthcare API.')
  parser.add_argument(
      '--prediction_service',
      type=str,
      default='CMLE',
      help='Service to call for prediction, either "CMLE" or "AutoML"')
  parser.add_argument(
      '--pubsub_timeout',
      type=int,
      default=None,
      help=
      'Number of seconds to wait for pubsub message to process until timeout. '
      'If set to None, it will wait indefinitely.')

  FLAGS, unparsed = parser.parse_known_args()
  if FLAGS.publisher_topic_path and not FLAGS.dicom_store_path:
    parser.error('--publisher_topic_path requires --dicom_store_path '
                 'to be set.')
  main()
